#ifndef MINESWEEPER_GRID_H
#define MINESWEEPER_GRID_H

#include "minesweeper.h"


Chunk *grid_get_quarter_chunk(Chunk ***const quarter, uint32_t *const restrict y_size, uint32_t *const restrict x_size, const Position *const abs_pos) {
	// Will expand the grid if it's not big enough yet
	const uint32_t pos_yc = abs_pos->y / CHUNK_HEIGHT;
	const uint32_t pos_xc = abs_pos->x / CHUNK_WIDTH;
	if(pos_yc >= *y_size) { // Ensure enough rows
		*quarter = realloc(*quarter, (pos_yc + 1) * sizeof **quarter);
		assert(*quarter != NULL);
		for(uint32_t r = *y_size; r != pos_yc + 1; ++r) { // Alloc their cols
			(*quarter)[r] = calloc(*x_size, sizeof ***quarter); // Set whole chunk(s) to 0 (CELL_NULL)
			assert((*quarter)[r] != NULL);
		}
		*y_size = pos_yc + 1;
	}
	if(pos_xc >= *x_size) { // Ensure enough cols
		for(uint32_t r = 0; r != *y_size; ++r) {
			(*quarter)[r] = realloc((*quarter)[r], (pos_xc + 1) * sizeof ***quarter);
			assert((*quarter)[r] != NULL);
			memset(&(*quarter)[r][*x_size], 0, (pos_xc - *x_size + 1) * sizeof ***quarter); // Set whole chunk(s) to 0 (CELL_NULL)
		}
		*x_size = pos_xc + 1;
	}
	return &(*quarter)[pos_yc][pos_xc];
}

Chunk *grid_get_chunk(Game *const game, const Position *const pos) {
	Grid *const grid = &game->grid;
	const bool x_neg = pos->x < 0;
	const bool y_neg = pos->y < 0;
	const Position abs_pos = {
		.x = x_neg ? -pos->x - 1 : pos->x,
		.y = y_neg ? -pos->y - 1 : pos->y
	};
	assert(abs_pos.x >= 0 && abs_pos.y >= 0);
	if(y_neg) {
		if(x_neg)
			return grid_get_quarter_chunk(&grid->nynx, &grid->nynx_y, &grid->nynx_x, &abs_pos);
		else
			return grid_get_quarter_chunk(&grid->nypx, &grid->nypx_y, &grid->nypx_x, &abs_pos);	
	} else {
		if(x_neg)
			return grid_get_quarter_chunk(&grid->pynx, &grid->pynx_y, &grid->pynx_x, &abs_pos);
		else
			return grid_get_quarter_chunk(&grid->pypx, &grid->pypx_y, &grid->pypx_x, &abs_pos);
	}
}

Cell *grid_get(Game *const game, const Position *const pos) {
	Chunk *const chunk = grid_get_chunk(game, pos);
	return &(*chunk)[(pos->y < 0 ? -pos->y - 1 : pos->y) % CHUNK_HEIGHT][(pos->x < 0 ? -pos->x - 1 : pos->x) % CHUNK_WIDTH];
}

Cell *grid_set(Game *const game, const Position *const pos, const Cell val) {
	Cell *const cell = grid_get(game, pos);
	*cell = val;
	return cell;
}

Cell *grid_get_and_gen(Game *const game, const Position *const pos) {
	Cell *const cell = grid_get(game, pos);
	if(*cell == CELL_NULL) {
		*cell |= CELL_UNCACHED;
		if(game->seen < 2 ? false : rand() <= RAND_MAX * MINE_DENSITY)
			*cell |= CELL_MINE;
	}
	return cell;
}

void grid_gen(Game *const game, const Position *const pos) {
	const bool mine = game->seen < 2 ? false : rand() <= RAND_MAX * MINE_DENSITY;
	grid_set(game, pos, mine ? CELL_MINE | CELL_UNCACHED : CELL_UNCACHED);
	return;
}

void grid_click_num(Game *const game, const Position *const pos) {
	Cell *const restrict cell = grid_get(game, pos);
	assert(*cell & CELL_CLICKED); // Should be clicked
	CellCache surr_mines;
	if(*cell & CELL_UNCACHED) { // Isn't cached, but it should be
		SDL_LogError(SDL_LOG_CATEGORY_ASSERT, "Clicked a visible cell which wasn't cached\n");
		surr_mines = cell_calc_cache(game, pos);
		cell_set_cache(cell, surr_mines);
	} else
		surr_mines = cell_get_cache(cell);
	if(!surr_mines)
		return;
	const Cell *restrict other_cell;
	Position other_pos;
	CellCache surr_flags = 0;
	bool click_surrounds = false;
loop_start:
	for(int32_t y_d = -1; y_d <= 1; ++y_d) {
		other_pos.y = pos->y + y_d;
		for(int32_t x_d = -1; x_d <= 1; ++x_d) {
			if(x_d == 0 && y_d == 0)
				continue;
			other_pos.x = pos->x + x_d; 
			other_cell = grid_get(game, &other_pos);
			assert(*other_cell != CELL_NULL); // Should be generated by now
			if(click_surrounds) {
				if(!(*other_cell & CELL_CLICKED))
					grid_click(game, &other_pos);
			} else {
				if(*other_cell & CELL_FLAGGED)
					++surr_flags;
			}
		}
	}
	if(!click_surrounds && surr_mines == surr_flags) {
		click_surrounds = true;
		goto loop_start;
	}
	return;
}

void grid_click(Game *const game, const Position *const pos) {
	Cell *const restrict cell = grid_get(game, pos);
	if(pups_use_space(game, pos)) // Clicked away from numbers
		return;
	if(*cell == CELL_NULL)
		grid_gen(game, pos);
	if(*cell & CELL_FLAGGED)
		return; // Can't click a flag
	else if(*cell & CELL_CLICKED) {
		grid_click_num(game, pos);
		return;
	}
	if(*cell & CELL_MINE) {
#ifndef SAFE_MODE
		if(!pups_use_save(game, pos)) // Save couldn't be used
			game_over(game, pos);
#endif
		return;
	}
	*cell |= CELL_CLICKED;
	++game->seen;

	CellCache cache;
	if(!(*cell & CELL_UNCACHED)) { // Already cached, should only occur with PUP_SPACE
#ifndef POWERUPS
		SDL_LogError(SDL_LOG_CATEGORY_ASSERT, "Clicked an already-cached cell\n");
#endif
		cache = cell_get_cache(cell);
	} else {
		cache = cell_calc_cache(game, pos);
		cell_set_cache(cell, cache);
	}
	rects_add(game, pos, cache); // Now visible
	pups_handle(game, cache);
	if(cache)
		goto finish;
	const Cell *restrict other_cell;
	Position other_pos;
	for(int32_t y_d = -1; y_d <= 1; ++y_d) { // If no surrounding mines, click all
		other_pos.y = pos->y + y_d;
		for(int32_t x_d = -1; x_d <= 1; ++x_d) {
			if(x_d == 0 && y_d == 0)
				continue;
			other_pos.x = pos->x + x_d;
			other_cell = grid_get(game, &other_pos);
			if(!(*other_cell & CELL_CLICKED))
				grid_click(game, &other_pos);
		}
	}
finish:
	assert(*cell != CELL_NULL);
	return;
}

void grid_flag(Game *const game, const Position *const pos) {
	Cell *const cell = grid_get_and_gen(game, pos);
	if(*cell & CELL_CLICKED)
		return; // Can't flag after clicking
	if(*cell & CELL_FLAGGED) { // Remove flag
		--game->flags;
		--game->seen;
		rects_rem(game, pos, NUM_COLORS);
	} else { // Add flag
		++game->flags;
		++game->seen;
		rects_add(game, pos, NUM_COLORS);
	}
	*cell ^= CELL_FLAGGED;
	assert(*cell != CELL_NULL);
	return;
}

void grid_move(Game *const game, const Direction dir, const bool jump) {
	if(!game->seen)
		return;
	int32_t *coord;
	bool sub;
	switch(dir) {
		case UP:
			coord = &game->cursor.y;
			sub = true;
			break;
		case DOWN:
			coord = &game->cursor.y;
			sub = false;
			break;
		case LEFT:
			coord = &game->cursor.x;
			sub = true;
			break;
		case RIGHT:
			coord = &game->cursor.x;
			sub = false;
			break;
		default:
			break;
	}
	const int32_t move_dist = jump ? JUMP_DIST : 1;
	if(sub)
		*coord -= move_dist;
	else
		*coord += move_dist;
	rects_move_all(game, dir, jump);
}


#endif // MINESWEEPER_GRID_H

